<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>On The Way</title>
  
  
  <link href="https://vincentxin-scott.github.io/atom.xml" rel="self"/>
  
  <link href="https://vincentxin-scott.github.io/"/>
  <updated>2021-02-01T06:16:22.476Z</updated>
  <id>https://vincentxin-scott.github.io/</id>
  
  <author>
    <name>Vincent Xin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>永久自动获得免费得HTTPS证书</title>
    <link href="https://vincentxin-scott.github.io/2021/01/28/%E6%9D%82%E8%AE%B0%E9%9A%8F%E7%AC%94/%E6%B0%B8%E4%B9%85%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%BE%97%E5%85%8D%E8%B4%B9%E7%9A%84HTTPS%E8%AF%81%E4%B9%A6--certbot/"/>
    <id>https://vincentxin-scott.github.io/2021/01/28/%E6%9D%82%E8%AE%B0%E9%9A%8F%E7%AC%94/%E6%B0%B8%E4%B9%85%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%BE%97%E5%85%8D%E8%B4%B9%E7%9A%84HTTPS%E8%AF%81%E4%B9%A6--certbot/</id>
    <published>2021-01-28T08:02:16.624Z</published>
    <updated>2021-02-01T06:16:22.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p><strong><em>拥有域名，拥有公网IP的服务器</em></strong></p><h2 id="官方主页了解一下"><a href="#官方主页了解一下" class="headerlink" title="官方主页了解一下"></a>官方主页了解一下</h2><p><a href="https://certbot.eff.org/">certbot</a>参考学习。</p><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><ol><li>用于获取HTTPS证书并自动更新</li><li>可以对代理文件进行自动维护<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2></li></ol><ul><li>OS： CentOS7</li><li>网站服务器： Nginx<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2></li></ul><ol><li>官方推荐首先安装<a href="https://snapcraft.io/docs/installing-snapd">snapd</a>,选择自己的系统进行安装。<blockquote><p>通过命令 cat /etc/centos-release  确认自己的系统版本</p></blockquote></li></ol><p>以安装centos7为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以使用以下命令将EPEL存储库添加到CentOS 7系统<span class="comment">#</span></span></span><br><span class="line">1. sudo yum install epel-release</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将EPEL存储库添加到CentOS安装中后，只需安装snapd软件包：</span></span><br><span class="line">2. sudo yum install snapd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装后，需要启用用于管理主快照通信套接字的systemd单元：</span></span><br><span class="line">3. sudo systemctl enable --now snapd.socket</span><br><span class="line"><span class="meta">#</span><span class="bash"> 要启用经典快照支持</span></span><br><span class="line">4. sudo ln -s /var/lib/snapd/snap /snap</span><br></pre></td></tr></table></figure><p>最后系统提示 重启系统去确保snap被正确的安装。但是我没有重启也可以使用</p><h3 id="安装certbot"><a href="#安装certbot" class="headerlink" title="安装certbot"></a>安装certbot</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装前先确保你的nsap保持的是最新的版本</span></span><br><span class="line">sudo snap install core; sudo snap refresh core</span><br><span class="line"><span class="meta">#</span><span class="bash">  安装certbot</span></span><br><span class="line">sudo snap install --classic certbot</span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保certbot命令可以被运行</span></span><br><span class="line">sudo ln -s /snap/bin/certbot /usr/bin/certbot</span><br></pre></td></tr></table></figure><h3 id="创建SSL证书并配置"><a href="#创建SSL证书并配置" class="headerlink" title="创建SSL证书并配置"></a>创建SSL证书并配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot --nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一次创建的时候会提示你输入邮箱，一个开启模式，一个是是否同意协议。</p><p>之后会创建会有提示：<br><img src="http://img.vincentxin.work/img/20210201135946.png"><br>你可以选择需要创建的域名，也可以选择全部。</p><p>创建好之后的效果<br><img src="http://img.vincentxin.work/img/20210201140313.png"><br>红色部分是cerbot 自动写入的。</p><h3 id="设置自动续期"><a href="#设置自动续期" class="headerlink" title="设置自动续期"></a>设置自动续期</h3><p>因为certbot生成的有效证书是三个月，为了方便，可以实现自动续期。</p><p>我们可以通过Linux自带的cron来实现自动续期</p><p>创建一个文件内容写 文件名xxxx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 */12 * * * certbot renew --quiet --renew-hook &quot;/etc/init.d/nginx reload&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>系统中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab xxxx </span><br></pre></td></tr></table></figure><p>系统会每天检查证书是否需要更新，如果更新了之后会对nginx重载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;拥有域名，拥有公网IP的服务器&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;官方主页了解一下&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="杂记随笔" scheme="https://vincentxin-scott.github.io/categories/%E6%9D%82%E8%AE%B0%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="certbot" scheme="https://vincentxin-scott.github.io/tags/certbot/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库PloarDB-X</title>
    <link href="https://vincentxin-scott.github.io/2020/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%98%BF%E9%87%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93PolarDB-X/"/>
    <id>https://vincentxin-scott.github.io/2020/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%98%BF%E9%87%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93PolarDB-X/</id>
    <published>2020-09-07T02:51:54.594Z</published>
    <updated>2020-09-22T09:52:40.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h1><p>PolarDB-X是由阿里巴巴自主研发的云原生分布式数据库，融合分布式SQL引擎DRDS与分布式自研存储X-DB，基于云原生一体化架构设计，可支撑千万级并发规模及百PB级海量存储</p><h1 id="产品特点"><a href="#产品特点" class="headerlink" title="产品特点"></a>产品特点</h1><h3 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h3><p>PolarDB-X将数据拆分到多个MySQL存储，使每个MySQL承担合适的并发、数据存储和计算负载，各个MySQL处于稳定状态。PolarDB-X层面处理分布式逻辑，最终得到一个具有稳定可靠、高度扩展性的分布式关系型数据库系统。</p><h3 id="高度可扩展"><a href="#高度可扩展" class="headerlink" title="高度可扩展"></a>高度可扩展</h3><h3 id="持续可运维"><a href="#持续可运维" class="headerlink" title="持续可运维"></a>持续可运维</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;产品介绍&quot;&gt;&lt;a href=&quot;#产品介绍&quot; class=&quot;headerlink&quot; title=&quot;产品介绍&quot;&gt;&lt;/a&gt;产品介绍&lt;/h1&gt;&lt;p&gt;PolarDB-X是由阿里巴巴自主研发的云原生分布式数据库，融合分布式SQL引擎DRDS与分布式自研存储X-DB，基于云原生</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分布式数据库" scheme="https://vincentxin-scott.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实践篇-MySQL是怎么保证主备一致的？</title>
    <link href="https://vincentxin-scott.github.io/2020/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C20MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/"/>
    <id>https://vincentxin-scott.github.io/2020/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C20MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</id>
    <published>2020-08-27T03:58:50.328Z</published>
    <updated>2020-09-22T09:52:40.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL是怎么保证主备一致的？"><a href="#MySQL是怎么保证主备一致的？" class="headerlink" title="MySQL是怎么保证主备一致的？"></a>MySQL是怎么保证主备一致的？</h1><p>在最开始，MySQL是以容易学习和放方便的高可用架构，被开发人员青睐的。而它的几乎所有的高可用架构，都直接依赖binlog。虽然这些高可用架构已经呈现出来越来越复杂的趋势，但都是从最基本的一主一备演化过来的。</p><h2 id="MySQL主备的基本原理"><a href="#MySQL主备的基本原理" class="headerlink" title="MySQL主备的基本原理"></a>MySQL主备的基本原理</h2><p><img src="http://img.vincentxin.work/img/20200827120412.png" alt="主备切换流程图"></p><p>在状态1中，客户端的读写都是直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行。这样可以保持节点B和A的数据是相同的。</p><p>在切换的时候，就切成状态2.这时候客户端读写访问的都是节点B，而节点A是B的备库。</p><p>建议将备库设置成只读模式：</p><ul><li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li><li>防止切换逻辑有bug；</li><li>可以用readonly状态，来判断节点角色。</li></ul><p>readonly设置对超级权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</p><h3 id="主从复制内部流程"><a href="#主从复制内部流程" class="headerlink" title="主从复制内部流程"></a>主从复制内部流程</h3><p><img src="http://img.vincentxin.work/img/20200827122018.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL是怎么保证主备一致的？&quot;&gt;&lt;a href=&quot;#MySQL是怎么保证主备一致的？&quot; class=&quot;headerlink&quot; title=&quot;MySQL是怎么保证主备一致的？&quot;&gt;&lt;/a&gt;MySQL是怎么保证主备一致的？&lt;/h1&gt;&lt;p&gt;在最开始，MySQL是以容易</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://vincentxin-scott.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库技术选型</title>
    <link href="https://vincentxin-scott.github.io/2020/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/"/>
    <id>https://vincentxin-scott.github.io/2020/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/</id>
    <published>2020-08-03T04:19:53.397Z</published>
    <updated>2020-08-03T10:35:23.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式数据库技术选型对比"><a href="#分布式数据库技术选型对比" class="headerlink" title="分布式数据库技术选型对比"></a>分布式数据库技术选型对比</h1><h2 id="OLAP-On-line-Analytical-Processing"><a href="#OLAP-On-line-Analytical-Processing" class="headerlink" title="OLAP(On-line Analytical Processing)"></a>OLAP(On-line Analytical Processing)</h2><p>事务处理：会有高并发且数据量级不大的查询，主要是用于管理事务的系统。此类系统专注于short on-line-tansactions 如INSERT, UPDATE, DELETE操作。通常存在此类系统中的数据都是以实体对象模型来存储数据，并满足3NF(数据库第三范式)。</p><h2 id="OLTP-On-line-Transaction-Processing"><a href="#OLTP-On-line-Transaction-Processing" class="headerlink" title="OLTP(On-line Transaction Processing)"></a>OLTP(On-line Transaction Processing)</h2><p>分析处理：查询频率较OLTP系统更低，但通常会涉及到非常复杂的聚合计算。 OLAP系统以维度模型来存储历史数据，其主要存储描述性的数据并且在结构上都是同质的。</p><h2 id="OLTP-and-OLAP对照"><a href="#OLTP-and-OLAP对照" class="headerlink" title="OLTP and OLAP对照"></a>OLTP and OLAP对照</h2><p><img src="http://img.vincentxin.work/img/20200803150226.png"></p><h2 id="分布式数据库中间件"><a href="#分布式数据库中间件" class="headerlink" title="分布式数据库中间件"></a>分布式数据库中间件</h2><h3 id="Cobar"><a href="#Cobar" class="headerlink" title="Cobar"></a>Cobar</h3><h3 id="MyCAT"><a href="#MyCAT" class="headerlink" title="MyCAT"></a>MyCAT</h3><h3 id="TDDL"><a href="#TDDL" class="headerlink" title="TDDL"></a>TDDL</h3><h3 id="DRDS"><a href="#DRDS" class="headerlink" title="DRDS"></a>DRDS</h3><h3 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h3><h3 id="DBProxy"><a href="#DBProxy" class="headerlink" title="DBProxy"></a>DBProxy</h3><h3 id="ShardingSphere–Sharding-JDBC"><a href="#ShardingSphere–Sharding-JDBC" class="headerlink" title="ShardingSphere–Sharding-JDBC"></a>ShardingSphere–Sharding-JDBC</h3><h3 id="ShardingSphere–Sharding-Proxy"><a href="#ShardingSphere–Sharding-Proxy" class="headerlink" title="ShardingSphere–Sharding-Proxy"></a>ShardingSphere–Sharding-Proxy</h3><h2 id="分布式数据库产品"><a href="#分布式数据库产品" class="headerlink" title="分布式数据库产品"></a>分布式数据库产品</h2><h3 id="PolarBD-X"><a href="#PolarBD-X" class="headerlink" title="PolarBD-X"></a>PolarBD-X</h3><h3 id="OceanBase"><a href="#OceanBase" class="headerlink" title="OceanBase"></a>OceanBase</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式数据库技术选型对比&quot;&gt;&lt;a href=&quot;#分布式数据库技术选型对比&quot; class=&quot;headerlink&quot; title=&quot;分布式数据库技术选型对比&quot;&gt;&lt;/a&gt;分布式数据库技术选型对比&lt;/h1&gt;&lt;h2 id=&quot;OLAP-On-line-Analytical-P</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分布式数据库" scheme="https://vincentxin-scott.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Transactional事务失效自检流程</title>
    <link href="https://vincentxin-scott.github.io/2020/05/29/Java/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%E6%8E%A2%E7%A9%B6/"/>
    <id>https://vincentxin-scott.github.io/2020/05/29/Java/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-05-29T06:12:24.360Z</published>
    <updated>2020-06-03T02:02:10.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-的传播行为"><a href="#Spring-的传播行为" class="headerlink" title="Spring 的传播行为"></a>Spring 的传播行为</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line">    REQUIRED(<span class="number">0</span>), </span><br><span class="line">    SUPPORTS(<span class="number">1</span>), </span><br><span class="line">    MANDATORY(<span class="number">2</span>), </span><br><span class="line">    REQUIRES_NEW(<span class="number">3</span>), </span><br><span class="line">    NOT_SUPPORTED(<span class="number">4</span>), </span><br><span class="line">    NEVER(<span class="number">5</span>), </span><br><span class="line">    NESTED(<span class="number">6</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务。则创建一个新事务。</p></li><li><p>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式继续运行。</p></li><li><p>MANDATORY:如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p></li><li><p> REQUIRES_NEW:创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p></li><li><p>NOT_SUPPORTED ：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 </p></li><li><p>NEVER ：以非事务方式运行，如果当前存在事务，则抛出异常。 </p></li><li><p>NESTED ：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED 。</p></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在继续探究前，先简单带过一下动态代理。<br>代理模式主要功能是为了增强一个类中的方法诞生的一种设计模式。<br>而代理模式分为动态代理和静态代理，动态代理的代理类是在运行时生成的，而静态代理是在编译时生成的。动态代理可以分为基于接口的JDK动态代理和基于类的Cglib动态代理。<br>下面讲解一下基于JDK的动态代理：<br>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//增强的目标类</span></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;先吃饭-----再看书&quot;</span>);</span><br><span class="line">        method.invoke(person, args);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line">        MyInvocationHandler myInvocationHandler = <span class="keyword">new</span> MyInvocationHandler(person);</span><br><span class="line">        System.out.println(Arrays.toString(Student.class.getInterfaces()));</span><br><span class="line">        Person proPerson = (Person) Proxy.newProxyInstance(Student.class.getClassLoader(), Student.class.getInterfaces(), myInvocationHandler);</span><br><span class="line">        proPerson.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为： 先吃饭-----再看书 读书</span></span><br></pre></td></tr></table></figure><h2 id="动态代理的坑"><a href="#动态代理的坑" class="headerlink" title="动态代理的坑"></a>动态代理的坑</h2><p>Spring事务是基于动态代理实现的。那么，Spring事务失效的真正原因和动态代理有什么关联呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring-的传播行为&quot;&gt;&lt;a href=&quot;#Spring-的传播行为&quot; class=&quot;headerlink&quot; title=&quot;Spring 的传播行为&quot;&gt;&lt;/a&gt;Spring 的传播行为&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="事务" scheme="https://vincentxin-scott.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>shell构建项目部署脚本</title>
    <link href="https://vincentxin-scott.github.io/2020/05/18/Shell/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/"/>
    <id>https://vincentxin-scott.github.io/2020/05/18/Shell/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/</id>
    <published>2020-05-18T03:36:36.574Z</published>
    <updated>2020-05-18T03:47:13.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="centos部署jar包脚本"><a href="#centos部署jar包脚本" class="headerlink" title="centos部署jar包脚本"></a>centos部署jar包脚本</h1><p>在～目录建立一个start.sh文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动的方法参数（[start|stop|restart|status]）</span></span><br><span class="line">PARAMETER=$1</span><br><span class="line"><span class="meta">#</span><span class="bash">jar包路径，加不加引号都行。 注意：等号两边 不能 有空格，否则会提示<span class="built_in">command</span>找不到</span></span><br><span class="line">JAR_NAME=$2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志路径，加不加引号都行。 注意：等号两边 不能 有空格，否则会提示<span class="built_in">command</span>找不到</span></span><br><span class="line">LOG_PATh=$3</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果输入格式不对，给出提示！</span></span><br><span class="line">tips() &#123;</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">        echo &quot;WARNING!!!......Tips, please use command: sh srart.sh [start|stop|restart|status].   For example: sh srart.sh start  &quot;</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动方法</span></span><br><span class="line">start() &#123;</span><br><span class="line">        # 重新获取一下pid，因为其它操作如stop会导致pid的状态更新</span><br><span class="line">        pid=`ps -ef |grep java | grep $JAR_NAME | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">        # -z 表示如果$pid为空时执行</span><br><span class="line">        if [ -z $pid ]; then </span><br><span class="line">        nohup java -jar $JAR_NAME &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">        pid=`ps -ef | grep $JAR_NAME | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">        echo &quot;Service $&#123;JAR_NAME&#125; is starting！pid=$&#123;pid&#125;&quot;</span><br><span class="line">                echo &quot;........................Here is the log..............................&quot;</span><br><span class="line">                echo &quot;.....................................................................&quot;</span><br><span class="line">        tail -f $LOG_PATh</span><br><span class="line">                echo &quot;........................Start successfully！.........................&quot;</span><br><span class="line">        else</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">                echo &quot;Service $&#123;JAR_NAME&#125; is already running,it&#x27;s pid = $&#123;pid&#125;. If necessary, please use command: sh srart.sh restart.&quot;</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止方法</span></span><br><span class="line">stop() &#123;</span><br><span class="line">                # 重新获取一下pid，因为其它操作如start会导致pid的状态更新</span><br><span class="line">        pid=`ps -ef | grep java | grep $JAR_NAME | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">        # -z 表示如果$pid为空时执行。 注意：每个命令和变量之间一定要前后加空格，否则会提示command找不到</span><br><span class="line">        if [ -z $pid ];then</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">        echo &quot;Service $&#123;JAR_NAME&#125; is not running! It&#x27;s not necessary to stop it!&quot;</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">        else</span><br><span class="line">                kill -9 $pid</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">                echo &quot;Service stop successfully！pid:$&#123;pid&#125; which has been killed forcibly!&quot;</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出运行状态方法</span></span><br><span class="line">status() &#123;</span><br><span class="line">        # 重新获取一下pid，因为其它操作如stop、restart、start等会导致pid的状态更新</span><br><span class="line">        pid=`ps -ef | grep java | grep $JAR_NAME | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">        # -z 表示如果$pid为空时执行。注意：每个命令和变量之间一定要前后加空格，否则会提示command找不到</span><br><span class="line">        if [ -z $pid ];then</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">        echo &quot;Service $&#123;JAR_NAME&#125; is not running!&quot;</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">        else</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">        echo &quot;Service $&#123;JAR_NAME&#125; is running. It&#x27;s pid=$&#123;pid&#125;&quot;</span><br><span class="line">                echo &quot;&quot;</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启方法</span></span><br><span class="line">restart() &#123;</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">        echo &quot;.............................Restarting..............................&quot;</span><br><span class="line">        echo &quot;.....................................................................&quot;</span><br><span class="line">                # 重新获取一下pid，因为其它操作如start会导致pid的状态更新</span><br><span class="line">        pid=`ps -ef | grep java | grep $JAR_NAME | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">        # -z 表示如果$pid为空时执行。 注意：每个命令和变量之间一定要前后加空格，否则会提示command找不到</span><br><span class="line">        if [ ! -z $pid ]; then</span><br><span class="line">                kill -9 $pid</span><br><span class="line">        fi</span><br><span class="line">        start</span><br><span class="line">        echo &quot;....................Restart successfully！...........................&quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据输入参数执行对应方法，不输入则执行tips提示方法</span></span><br><span class="line">case &quot;$&#123;PARAMETER&#125;&quot; in</span><br><span class="line">   &quot;start&quot;)</span><br><span class="line">     start</span><br><span class="line">     ;;</span><br><span class="line">   &quot;stop&quot;)</span><br><span class="line">     stop</span><br><span class="line">     ;;</span><br><span class="line">   &quot;status&quot;)</span><br><span class="line">     status</span><br><span class="line">     ;;</span><br><span class="line">   &quot;restart&quot;)</span><br><span class="line">     restart</span><br><span class="line">     ;;</span><br><span class="line">   *)</span><br><span class="line">     tips</span><br><span class="line">     ;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h2><p>在脚本目录执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh start.sh start（启动参数[start|stop|restart|status]）  &#x2F;use&#x2F;local&#x2F;demo&#x2F;xxxx.jar(jar包的位置名称)  &#x2F;user&#x2F;var&#x2F;demo&#x2F;XXXX.log（这个是项目配置的日志地址）</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;centos部署jar包脚本&quot;&gt;&lt;a href=&quot;#centos部署jar包脚本&quot; class=&quot;headerlink&quot; title=&quot;centos部署jar包脚本&quot;&gt;&lt;/a&gt;centos部署jar包脚本&lt;/h1&gt;&lt;p&gt;在～目录建立一个start.sh文件。&lt;/p</summary>
      
    
    
    
    <category term="脚本语言" scheme="https://vincentxin-scott.github.io/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="shell" scheme="https://vincentxin-scott.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序获取公众号授权</title>
    <link href="https://vincentxin-scott.github.io/2020/05/18/uni-app/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%88%E6%9D%83/"/>
    <id>https://vincentxin-scott.github.io/2020/05/18/uni-app/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%88%E6%9D%83/</id>
    <published>2020-05-18T03:36:05.632Z</published>
    <updated>2020-05-18T09:03:24.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>微信小程序需要给用户（单个或多个）推送业务消息。</p><ul><li>没有支付业务（不能用服务通知）</li><li>不能有数量限制（根据业务需求消息数量不少）</li></ul><h2 id="微信公众号有消息模版可以给用户推送消息"><a href="#微信公众号有消息模版可以给用户推送消息" class="headerlink" title="微信公众号有消息模版可以给用户推送消息"></a>微信公众号有消息模版可以给用户推送消息</h2><p>需要公众号关联小程序(互相跳转)</p><h2 id="如何解决小程序用户于公众号用户匹配"><a href="#如何解决小程序用户于公众号用户匹配" class="headerlink" title="如何解决小程序用户于公众号用户匹配"></a>如何解决小程序用户于公众号用户匹配</h2><h3 id="通过UnionID来实现小程序和公众号openId关联。"><a href="#通过UnionID来实现小程序和公众号openId关联。" class="headerlink" title="通过UnionID来实现小程序和公众号openId关联。"></a>通过UnionID来实现小程序和公众号openId关联。</h3><ul><li>用户关注公众号，直接持久化用户unionId和openId。</li><li>通过微信开发的api同步公众号关注用户信息。</li></ul><p>在小程序中只需要获取unionId就可以找到对应的公众号openId，进行消息发送。</p><h3 id="通过在小程序中获取微信公众号的code"><a href="#通过在小程序中获取微信公众号的code" class="headerlink" title="通过在小程序中获取微信公众号的code"></a>通过在小程序中获取微信公众号的code</h3><ul><li>后台解析微信公众号的code，获取openId，和小程序的openId及账号信息进行关联。</li></ul><h2 id="主要讨论在小程序中如何获取公众号code"><a href="#主要讨论在小程序中如何获取公众号code" class="headerlink" title="主要讨论在小程序中如何获取公众号code"></a>主要讨论在小程序中如何获取公众号code</h2><ol><li>使用小程序的 web-view组件，打开H5公众号授权页面。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;web-view :src=<span class="string">&#x27;src_url&#x27;</span>&gt;&lt;/web-view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">src_url: <span class="string">&#x27;https://XXXXXXXXXXXXXXXX&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li>H5页面部署在服务器上，小程序跳转当前页面后，直接访问微信公众号进行授权，微信授权完成后返回当前页面，页面解析授权是否完成，授权成功后跳转回小程序的登录页面。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>微信授权中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 微信jssdk --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://res.wx.qq.com/open/js/jweixin-1.3.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">getQueryVariable</span>(<span class="params">variable</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> query = <span class="built_in">window</span>.location.search.substring(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vars = query.split(<span class="string">&quot;&amp;&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vars.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> pair = vars[i].split(<span class="string">&quot;=&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (pair[<span class="number">0</span>] == variable) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> pair[<span class="number">1</span>];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> (<span class="literal">false</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> wxcode = getQueryVariable(<span class="string">&quot;code&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> httpUrl = <span class="string">&#x27;https://XXXXXXXXXXXXXXXXXXXXXX&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (wxcode) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//console.log(wxcode);</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line">            wx.miniProgram.redirectTo(&#123;</span><br><span class="line"><span class="javascript">                url: <span class="string">&#x27;/pages/rn-login/rn-wxlogin?code=&#x27;</span> + wxcode,</span></span><br><span class="line">            &#125;)</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line">            wx.miniProgram.redirectTo(&#123;</span><br><span class="line"><span class="javascript">                url: <span class="string">&#x27;/pages/rn-login/rn-wxlogin?code=&#x27;</span> + wxcode,</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> url = <span class="string">&#x27;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#x27;</span></span></span><br><span class="line"><span class="javascript">                + <span class="string">&quot;XXXXXXXXXXX&quot;</span></span></span><br><span class="line"><span class="javascript">                + <span class="string">&#x27;&amp;redirect_uri=&#x27;</span></span></span><br><span class="line">                + httpUrl</span><br><span class="line"><span class="javascript">                + <span class="string">&#x27;&amp;response_type=code&#x27;</span></span></span><br><span class="line"><span class="javascript">                + <span class="string">&#x27;&amp;scope=snsapi_base&#x27;</span></span></span><br><span class="line"><span class="javascript">                + <span class="string">&#x27;&amp;state=STATE#wechat_redirect&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.location.href = url;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> url = <span class="string">&#x27;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#x27;</span></span></span><br><span class="line"><span class="javascript">                + <span class="string">&quot;XXXXXXXXXXXXXXXX&quot;</span></span></span><br><span class="line"><span class="javascript">                + <span class="string">&#x27;&amp;redirect_uri=&#x27;</span></span></span><br><span class="line">                + httpUrl</span><br><span class="line"><span class="javascript">                + <span class="string">&#x27;&amp;response_type=code&#x27;</span></span></span><br><span class="line"><span class="javascript">                + <span class="string">&#x27;&amp;scope=snsapi_base&#x27;</span></span></span><br><span class="line"><span class="javascript">                + <span class="string">&#x27;&amp;state=STATE#wechat_redirect&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.location.href = url;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>小程序登录页面通过onload来监听授权参数信息并获得<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="function"><span class="keyword">function</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (option &amp;&amp; option.code) &#123;</span><br><span class="line">getApp().globalData.isFristGetCode = <span class="literal">true</span>;</span><br><span class="line">uni.reLaunch(&#123;</span><br><span class="line">url: <span class="string">&#x27;./rn-login?code=&#x27;</span> + option.code</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动一个计数器,检测5秒后时候获取到code</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//检测获取到code没有</span></span><br><span class="line">    <span class="keyword">if</span> (!getApp().globalData.isFristGetCode) &#123; </span><br><span class="line">    uni.reLaunch(&#123;</span><br><span class="line">    url: <span class="string">&#x27;./rn-login&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="comment">//TODO handle the exception</span></span><br><span class="line">uni.reLaunch(&#123;</span><br><span class="line">url: <span class="string">&#x27;./rn-login&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h2&gt;&lt;p&gt;微信小程序需要给用户（单个或多个）推送业务消息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有支付业务（不能用服务通知）&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="小程序" scheme="https://vincentxin-scott.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信公众号，微信小程序" scheme="https://vincentxin-scott.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%8C%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>05｜Docker-Compose</title>
    <link href="https://vincentxin-scott.github.io/2020/04/25/Docker/docker%20|%2005Docker-compose/"/>
    <id>https://vincentxin-scott.github.io/2020/04/25/Docker/docker%20|%2005Docker-compose/</id>
    <published>2020-04-25T02:49:46.943Z</published>
    <updated>2020-04-28T07:40:50.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><p>前提先安装docker 参考前面的文档。</p><h3 id="从github上下载docker-compose二进制文件安装"><a href="#从github上下载docker-compose二进制文件安装" class="headerlink" title="从github上下载docker-compose二进制文件安装"></a>从github上下载docker-compose二进制文件安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> github 下载</span></span><br><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> daocloud  下载（速度快）</span></span><br><span class="line">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install docker-compose</span><br></pre></td></tr></table></figure><h3 id="验证测试结果"><a href="#验证测试结果" class="headerlink" title="验证测试结果"></a>验证测试结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose --version</span></span><br><span class="line"> </span><br><span class="line">docker-compose version 1.25.5, build 8a1c60f6</span><br></pre></td></tr></table></figure><h3 id="删除docker-compose"><a href="#删除docker-compose" class="headerlink" title="删除docker-compose"></a>删除docker-compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="创建Docker-compose-yml文件"><a href="#创建Docker-compose-yml文件" class="headerlink" title="创建Docker-compose.yml文件"></a>创建Docker-compose.yml文件</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装docker-compose&quot;&gt;&lt;a href=&quot;#安装docker-compose&quot; class=&quot;headerlink&quot; title=&quot;安装docker-compose&quot;&gt;&lt;/a&gt;安装docker-compose&lt;/h2&gt;&lt;p&gt;前提先安装docker 参考</summary>
      
    
    
    
    <category term="DevOps" scheme="https://vincentxin-scott.github.io/categories/DevOps/"/>
    
    
    <category term="Docker" scheme="https://vincentxin-scott.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>01｜ORACLE基础篇-建表并主键自增</title>
    <link href="https://vincentxin-scott.github.io/2020/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93/ORACLE/oracle%EF%BD%9C01%E5%BB%BA%E8%A1%A8%E5%B9%B6%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E/"/>
    <id>https://vincentxin-scott.github.io/2020/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93/ORACLE/oracle%EF%BD%9C01%E5%BB%BA%E8%A1%A8%E5%B9%B6%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E/</id>
    <published>2020-04-20T08:17:10.397Z</published>
    <updated>2020-04-26T09:46:46.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &quot;TSMIS&quot;.&quot;TB_USER_WECHAT_BINDING&quot; </span><br><span class="line">   (&quot;USER_ID&quot; NUMBER(<span class="number">16</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ENABLE, </span><br><span class="line">&quot;WX_OPENID&quot; VARCHAR2(<span class="number">64</span>), </span><br><span class="line">&quot;CREATE_TIME&quot; <span class="type">DATE</span> <span class="keyword">DEFAULT</span> sysdate, </span><br><span class="line">&quot;BINDING_TIME&quot; <span class="type">DATE</span> <span class="keyword">DEFAULT</span> sysdate, </span><br><span class="line">&quot;STATE&quot; NUMBER(<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line"><span class="keyword">CONSTRAINT</span> &quot;PK_TB_USER_WECHAT_BINDING&quot; <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (&quot;USER_ID&quot;));</span><br></pre></td></tr></table></figure><h2 id="建立自增-SEQUENCE"><a href="#建立自增-SEQUENCE" class="headerlink" title="建立自增 SEQUENCE"></a>建立自增 SEQUENCE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SEQUENCE SEQ_TB_USER_WECHAT_BINDING</span><br><span class="line">   INCREMENT <span class="keyword">BY</span> <span class="number">1</span> <span class="comment">-- 每次加几个</span></span><br><span class="line">   <span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span> <span class="comment">-- 从1开始计数</span></span><br><span class="line">   NOMAXVALUE <span class="comment">-- 不设置最大值</span></span><br><span class="line">   NOCYCLE <span class="comment">-- 一直累加，不循环</span></span><br><span class="line">   NOCACHE; <span class="comment">-- 不建缓冲区</span></span><br></pre></td></tr></table></figure><h3 id="查看已经建立的sequence"><a href="#查看已经建立的sequence" class="headerlink" title="查看已经建立的sequence"></a>查看已经建立的sequence</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_sequences;</span><br></pre></td></tr></table></figure><h3 id="删除已经建立的sequence"><a href="#删除已经建立的sequence" class="headerlink" title="删除已经建立的sequence"></a>删除已经建立的sequence</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SEQUENCE SEQ_TB_USER_WECHAT_BINDING;</span><br></pre></td></tr></table></figure><h2 id="id设置默认值（触发方式的一种）"><a href="#id设置默认值（触发方式的一种）" class="headerlink" title="id设置默认值（触发方式的一种）"></a>id设置默认值（触发方式的一种）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> TB_USER_WECHAT_BINDING modify USER_ID <span class="keyword">default</span> &quot;TSMIS&quot;.&quot;SEQ_TB_USER_WECHAT_BINDING&quot;.&quot;NEXTVAL&quot;;</span><br></pre></td></tr></table></figure><h2 id="触发器-触发方式的另一种"><a href="#触发器-触发方式的另一种" class="headerlink" title="触发器(触发方式的另一种)"></a>触发器(触发方式的另一种)</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建表&quot;&gt;&lt;a href=&quot;#建表&quot; class=&quot;headerlink&quot; title=&quot;建表&quot;&gt;&lt;/a&gt;建表&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="ORACLE" scheme="https://vincentxin-scott.github.io/tags/ORACLE/"/>
    
  </entry>
  
  <entry>
    <title>01｜SpringBoot整合Activiti Modeler</title>
    <link href="https://vincentxin-scott.github.io/2020/04/17/%E5%B7%A5%E4%BD%9C%E6%B5%81/01%EF%BD%9C%E5%85%88%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E5%9C%A8%E8%AF%B4/"/>
    <id>https://vincentxin-scott.github.io/2020/04/17/%E5%B7%A5%E4%BD%9C%E6%B5%81/01%EF%BD%9C%E5%85%88%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E5%9C%A8%E8%AF%B4/</id>
    <published>2020-04-17T07:56:10.841Z</published>
    <updated>2020-04-17T09:50:59.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本说明："><a href="#版本说明：" class="headerlink" title="版本说明："></a>版本说明：</h2><ul><li>Spring boot: 2.1.4.RELEASE  </li><li>activiti: 6.0.0  </li><li>Mybatis-plus: 3.3.0 <h2 id=""><a href="#" class="headerlink" title=""></a></h2></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;版本说明：&quot;&gt;&lt;a href=&quot;#版本说明：&quot; class=&quot;headerlink&quot; title=&quot;版本说明：&quot;&gt;&lt;/a&gt;版本说明：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring boot: 2.1.4.RELEASE  &lt;/li&gt;
&lt;li&gt;activiti: 6.0.</summary>
      
    
    
    
    <category term="工作流" scheme="https://vincentxin-scott.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
    
    <category term="Activiti" scheme="https://vincentxin-scott.github.io/tags/Activiti/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity介绍</title>
    <link href="https://vincentxin-scott.github.io/2020/03/20/SpringSecurity/01%EF%BD%9CSpringSecurity%E4%BB%8B%E7%BB%8D/"/>
    <id>https://vincentxin-scott.github.io/2020/03/20/SpringSecurity/01%EF%BD%9CSpringSecurity%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-03-20T14:58:00.476Z</published>
    <updated>2020-03-21T03:07:14.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Security-jar包介绍"><a href="#Spring-Security-jar包介绍" class="headerlink" title="Spring Security jar包介绍"></a>Spring Security jar包介绍</h1><p>spring-security-core.jar<br>核心包，任何Spring Security 安全功能都包含此包。</p><p>spring-security-web.jar<br>web功能必备，包含过滤器和相关的Web安全基础结构代码。</p><p>spring-security-config.jar<br>用于解析xml配置文件，用到Spring Security的xml配置文件的就要用到此包。</p><p>spring-security-taglibs.jar<br>Spring Security 提供的动态标签库，jsp页面可以用。</p><p>注意：后面两个包包含了 前面所有的包。</p><h1 id="Spring-Security-过滤器介绍"><a href="#Spring-Security-过滤器介绍" class="headerlink" title="Spring Security 过滤器介绍"></a>Spring Security 过滤器介绍</h1><ol><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Security-jar包介绍&quot;&gt;&lt;a href=&quot;#Spring-Security-jar包介绍&quot; class=&quot;headerlink&quot; title=&quot;Spring Security jar包介绍&quot;&gt;&lt;/a&gt;Spring Security jar包</summary>
      
    
    
    
    <category term="Spring" scheme="https://vincentxin-scott.github.io/categories/Spring/"/>
    
    
    <category term="SpringSecurity" scheme="https://vincentxin-scott.github.io/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>在Linux中查看JDK安装路径</title>
    <link href="https://vincentxin-scott.github.io/2020/03/18/Linux/Linux%E4%B8%AD%E6%9F%A5%E7%9C%8BJDK%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/"/>
    <id>https://vincentxin-scott.github.io/2020/03/18/Linux/Linux%E4%B8%AD%E6%9F%A5%E7%9C%8BJDK%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/</id>
    <published>2020-03-18T06:04:55.415Z</published>
    <updated>2020-03-18T06:50:17.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="which-java"><a href="#which-java" class="headerlink" title="which java"></a>which java</h1><p>/usr/bin/java</p><h1 id="ls-lrt-usr-bin-java"><a href="#ls-lrt-usr-bin-java" class="headerlink" title="ls -lrt /usr/bin/java"></a>ls -lrt /usr/bin/java</h1><p>lrwxrwxrwx. 1 root root 22 3月  31 20:07 /usr/bin/java -&gt; /etc/alternatives/java</p><h1 id="ls-lrt-etc-alternatives-java"><a href="#ls-lrt-etc-alternatives-java" class="headerlink" title="ls -lrt /etc/alternatives/java"></a>ls -lrt /etc/alternatives/java</h1><p>lrwxrwxrwx. 1 root root 71 3月  31 20:07 /etc/alternatives/java -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64/jre/bin/java</p><h1 id="cd-usr-lib-jvm"><a href="#cd-usr-lib-jvm" class="headerlink" title="cd /usr/lib/jvm/"></a>cd /usr/lib/jvm/</h1><p>OK</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;which-java&quot;&gt;&lt;a href=&quot;#which-java&quot; class=&quot;headerlink&quot; title=&quot;which java&quot;&gt;&lt;/a&gt;which java&lt;/h1&gt;&lt;p&gt;/usr/bin/java&lt;/p&gt;
&lt;h1 id=&quot;ls-lrt-usr-b</summary>
      
    
    
    
    <category term="Linux" scheme="https://vincentxin-scott.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://vincentxin-scott.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在Linux中配置ssh密钥</title>
    <link href="https://vincentxin-scott.github.io/2020/03/18/%E6%9D%82%E8%AE%B0%E9%9A%8F%E7%AC%94/Linux%E4%B8%AD%E9%85%8D%E7%BD%AEssh%E5%AF%86%E9%92%A5/"/>
    <id>https://vincentxin-scott.github.io/2020/03/18/%E6%9D%82%E8%AE%B0%E9%9A%8F%E7%AC%94/Linux%E4%B8%AD%E9%85%8D%E7%BD%AEssh%E5%AF%86%E9%92%A5/</id>
    <published>2020-03-18T05:23:48.803Z</published>
    <updated>2020-03-18T06:04:30.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ssh密钥作用"><a href="#ssh密钥作用" class="headerlink" title="ssh密钥作用"></a>ssh密钥作用</h1><p>在Linux中配置ssh密钥,在Git中使用SSH协议访问Github，使用 SSH 协议, 您可以连接并验证远程服务器和服务。在每次访问时连接到服务而不提供用户名或密码。</p><h1 id="第一步：检查是否存在SSH密钥"><a href="#第一步：检查是否存在SSH密钥" class="headerlink" title="第一步：检查是否存在SSH密钥"></a>第一步：检查是否存在SSH密钥</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/.ssh</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200318132807.png"></p><p>如果不存在就会显示无法访问</p><h1 id="第二步：生成SSH-key"><a href="#第二步：生成SSH-key" class="headerlink" title="第二步：生成SSH key"></a>第二步：生成SSH key</h1><h2 id="输入指令："><a href="#输入指令：" class="headerlink" title="输入指令："></a>输入指令：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure><p>字母C一定要大写</p><ul><li>Enter file in which to save the key (~/.ssh/id_rsa): 提示文件存放位置，一般情况下就是存储在当前用户下.ssh文件夹下面。【直接回车】。</li><li>Enter passphrase (empty for no passphrase)：提示输入密码</li><li>Enter same passphrase again: 输入确认密码</li></ul><p>此时可以在/～/.ssh中看到 id_rsa(私钥) 和id_rsa_pub（公钥）</p><h1 id="第三步：连接gitlab、github、gitee"><a href="#第三步：连接gitlab、github、gitee" class="headerlink" title="第三步：连接gitlab、github、gitee"></a>第三步：连接gitlab、github、gitee</h1><ul><li><p>粘贴id_rsa_pub公钥中的内容，cat、vim或者其他工具直接粘贴出来。</p></li><li><p>github网站上，右上角头像，点击settings==》SSH and GPC keys ==》new SSH key。粘贴公钥，确定完成。</p></li><li><p>测试 ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;</a></p></li></ul><p>其他类似。</p><h1 id="实现远程服务器免密登录连接"><a href="#实现远程服务器免密登录连接" class="headerlink" title="实现远程服务器免密登录连接"></a>实现远程服务器免密登录连接</h1><h2 id="第一步：修改远程服务器sshd服务的配置文件"><a href="#第一步：修改远程服务器sshd服务的配置文件" class="headerlink" title="第一步：修改远程服务器sshd服务的配置文件"></a>第一步：修改远程服务器sshd服务的配置文件</h2><p>vim  /etc/ssh/sshd_config<br>修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes     # RSA认证</span><br><span class="line">PubkeyAuthentication yes  # 公钥认证</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys  # 公钥认证文件路径</span><br></pre></td></tr></table></figure><p>之后重启sshd  systemctl restart sshd</p><h2 id="第二部-将之前我们生成的公钥加入到服务器-ssh-authorized-keys文件中"><a href="#第二部-将之前我们生成的公钥加入到服务器-ssh-authorized-keys文件中" class="headerlink" title="第二部 将之前我们生成的公钥加入到服务器.ssh/authorized_keys文件中"></a>第二部 将之前我们生成的公钥加入到服务器.ssh/authorized_keys文件中</h2><p>依旧是复制粘贴，vim保存退出，搞定。</p><h3 id="配置本地config文件。"><a href="#配置本地config文件。" class="headerlink" title="配置本地config文件。"></a>配置本地config文件。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host vps                  # 一个便于你区别这是哪台机器的名字</span><br><span class="line">    HostName xx.xx.xx.xx  # 目的机器的ip</span><br><span class="line">    User username         # ssh登陆时候的用户名</span><br><span class="line">    Port 22               # ssh所使用的端口，默认是22</span><br><span class="line">    IdentityFile /~/.ssh/id_rsa    # 对应服务器公钥的本地私钥文件路径</span><br></pre></td></tr></table></figure><p>注意：～是指当前用户下地址，绝对路径自己pwd就可以看到了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ssh密钥作用&quot;&gt;&lt;a href=&quot;#ssh密钥作用&quot; class=&quot;headerlink&quot; title=&quot;ssh密钥作用&quot;&gt;&lt;/a&gt;ssh密钥作用&lt;/h1&gt;&lt;p&gt;在Linux中配置ssh密钥,在Git中使用SSH协议访问Github，使用 SSH 协议, 您可以</summary>
      
    
    
    
    <category term="杂记随笔" scheme="https://vincentxin-scott.github.io/categories/%E6%9D%82%E8%AE%B0%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="解决问题" scheme="https://vincentxin-scott.github.io/tags/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Navicat 导入数据报错 --- 1153 - Got a packet bigger than &#39;max_allowed_packet&#39; bytes</title>
    <link href="https://vincentxin-scott.github.io/2020/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%E6%8A%A5%E9%94%99%EF%BD%9C1153-max_allowed_packet%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    <id>https://vincentxin-scott.github.io/2020/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%E6%8A%A5%E9%94%99%EF%BD%9C1153-max_allowed_packet%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</id>
    <published>2020-03-16T15:31:24.999Z</published>
    <updated>2020-04-23T01:23:36.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以MariaDB为例在linux或mac中"><a href="#以MariaDB为例在linux或mac中" class="headerlink" title="以MariaDB为例在linux或mac中"></a>以MariaDB为例在linux或mac中</h2><p>在/etc/my.cnf 或者 /etc/my.cnf.d/server.cnf中修改一下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">max_allowed_packet = 10M</span><br></pre></td></tr></table></figure><p>之后重启mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mariadb</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;以MariaDB为例在linux或mac中&quot;&gt;&lt;a href=&quot;#以MariaDB为例在linux或mac中&quot; class=&quot;headerlink&quot; title=&quot;以MariaDB为例在linux或mac中&quot;&gt;&lt;/a&gt;以MariaDB为例在linux或mac中&lt;/</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL(MariaDB)报错处理" scheme="https://vincentxin-scott.github.io/tags/MySQL-MariaDB-%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实践篇-MySQL是怎么保证数据不丢的？</title>
    <link href="https://vincentxin-scott.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C19MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/"/>
    <id>https://vincentxin-scott.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C19MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</id>
    <published>2020-03-12T15:07:14.138Z</published>
    <updated>2020-04-23T01:23:36.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL是怎么保证数据不丢的？"><a href="#MySQL是怎么保证数据不丢的？" class="headerlink" title="MySQL是怎么保证数据不丢的？"></a>MySQL是怎么保证数据不丢的？</h1><p>之前介绍了WAL机制 write ahead log 得到结论是：只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复。</p><p>redo log的写入流程是怎样的，如何确保redo log 真实地写入了磁盘。</p><h2 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h2><p>其实，binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就设计到了binlog cache的保存问题。</p><p>系统给binlog cache分配到了一片内存，每个线程一个，参数binlog_cache_size用于控制单个线程内binlog cache 所占用内存的大小。如果超过这个参数规定的大小，就要暂存到磁盘。</p><p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200313104345.png"></p><p>可以看到，每个线程有自己binlog cache，但是共同一份binlog文件。</p><ul><li>图中write，指的就是把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li><li>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS。</li></ul><p>write和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog=0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog = 1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog=N(N&gt;1)的时候，表示每次提交事务都write，但积累N个事务后才fsync。</li></ol><p>因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100～1000中的某个数值。</p><p>但是，将sync_binlog设置为N，对饮的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p><h2 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h2><p>事务在执行过程中，生成的redo log是要先写到redo log buffer的。</p><p>如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。由于事务没有提交，所以这时日志也不会有损失。</p><p>那么另外一个问题，事务没有提交的时候，redo log buffer中的部分日志有没有可能被持久化到磁盘呢？</p><p>这个问题，要从redo log可能存在的三种状态说起。这三种状态，对应的就是图2中的三个颜色快。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200313110355.png"></p><p>这三种状态分别是：</p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘（write），但是没有持久化(sync)，物理上是在文件系统的page cache里面，也就是黄色的部分；</li><li>持久化到磁盘，对应的hard disk，也就是图中的绿色部分。</li></ol><p>日志写到redo log buffer是很快的，write到page cache也差不多，但是持久化到磁盘的速度就慢多了。</p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，他有三种可能的取值。</p><ol><li>设置为0的时候，表示每次事务提交都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p>InnoDB有一个后台线程,每隔一秒，就会把redo log buffer中的日志，调用wirte写到文件系统的page cache，然后调用fsync持久化到磁盘。</p><p>注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p><p>时间上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中。</p><ol><li><p>一种是，redo log buffer占用的空间即将达到innodb_log_buffer_size一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache。</p></li><li><p>另一种，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</p></li></ol><p>假设一个事务A执行到一半，已经写了一些redo log到buffer中，这时候有另外一个线程的事务B提交，如果innodb_flush_log_at_trx_commit设置的是1，那么按照这个参数的逻辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo log buffer里的日志一起持久化到磁盘。</p><p>这里需要说明的是，介绍的两阶段提交的时候说过，时序上redo log先prepare，再写binlog，最后再把redo log commit。</p><p>如果把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepare阶段就要持久化一次，因为有一点奔溃恢复逻辑是要依赖于prepare的redo log，再加上binlog来恢复。</p><p>每秒一次后台轮询刷盘，再加上奔溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到这个文件系统的page cache中就够了。</p><p>通常我们说MySQL的双1配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成1。也就说，一个事务完整提交前，需要等待两次刷盘，一次是redo log(prepare),一次是binlog。</p><p>这意味着MySQL看到TPS是每秒两万的话，每秒就会写四万次磁盘。但是，用测试工具测试出来，磁盘能力也就是两万左右，怎么能实现两万的TPS？</p><h4 id="用到组提交-group-commit-机制了。"><a href="#用到组提交-group-commit-机制了。" class="headerlink" title="用到组提交(group commit)机制了。"></a>用到组提交(group commit)机制了。</h4><p>首先介绍日志逻辑序列号(log sequence number,LSN)的概念。LSN是单调递增的，用来对应redo log的一个个写入点。每次写入的长度为length的redo log，LSN的值就会加上length。</p><p>LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。关于LSN 和redo log、checkpoint的关系，后面会详细展开。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200313160052.png"></p><p>三个并发事务(trx1,trx2,trx3)在prepare阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120和160。</p><ol><li>trx1是第一个到达的，会被选为这个组的leader;</li><li>等trx1要开始写盘的时候，这个组里面已经有三个事务，这时候LSN变成了160；</li><li>trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘了；</li><li>这时候trx2和trx3就可以直接返回了。</li></ol><p>所以，一次组提交里面，组员越多，节约磁盘IOPS的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p><p>在并发更新场景下，第一事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。</p><p>为了让一次fsync带的组员更多，MySQL有一个有趣的优化：拖时间。</p><p>MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后，也就是说。<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200313160948.png"></p><p>这样一来，binlog也可以组提交了。第4步binlog fsync到磁盘时，如果有多个事务的binlog已经写完了，也时一起持久化的，这样可以减少IOPS的消耗。</p><p>不过通常情况下第3步执行得会很快，所以binlog的write和fsync间的间隔时间短，导致能集合到一起持久化的binlog比较少，因此binlog的组提交的效果通常不如redo log的效果那么好。</p><p>如果你想提升binlog组提交的效果，可以通过设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count来实现。</p><ol><li>binlog_group_commit_sync_delay参数，便是延迟多少微妙后才调用fsync；</li><li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li></ol><p>这个两个条件是或的关系，也就说只要满足条件就会调用fsync。</p><p>所以当binlog_group_commit_sync_delay设置为0的时候，binglog_group_commit_sync_no_delay_count也无效了。</p><p>WAL机制主要得益于两个方面：<br>1.redo log和binlog都是顺序写，磁盘的顺序写比随机写速度快；<br>2. 组提交机制，可以大幅度降低磁盘IOPS消耗。</p><h2 id="如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？"><a href="#如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？" class="headerlink" title="如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？"></a>如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？</h2><ol><li>设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外来的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li><li>将sync_binlog设置为大于1的值（比较常见的是100～1000）。这样做的风险是，主机down之后会丢失binlog日志。</li><li>将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机down的时候会丢失数据。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL是怎么保证数据不丢的？&quot;&gt;&lt;a href=&quot;#MySQL是怎么保证数据不丢的？&quot; class=&quot;headerlink&quot; title=&quot;MySQL是怎么保证数据不丢的？&quot;&gt;&lt;/a&gt;MySQL是怎么保证数据不丢的？&lt;/h1&gt;&lt;p&gt;之前介绍了WAL机制 wri</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://vincentxin-scott.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实践篇-MySQL有哪些“饮鸩止渴”提高性能的方法？</title>
    <link href="https://vincentxin-scott.github.io/2020/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C18MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E2%80%9C%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E2%80%9D%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://vincentxin-scott.github.io/2020/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C18MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E2%80%9C%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E2%80%9D%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-02-25T03:38:10.413Z</published>
    <updated>2020-04-23T01:23:36.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL实践篇-MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#MySQL实践篇-MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="MySQL实践篇-MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>MySQL实践篇-MySQL有哪些“饮鸩止渴”提高性能的方法？</h1><h2 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h2><p>正常的短连接模式就是连接到数据库后，执行很少的SQL语句断开，下次需要的时候再重新连，如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。</p><p>MySQL建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。</p><p>在数据库压力很小的时候，这些额外的成本并不明显。</p><p>但是，短连接模型存在一个风险，就是一旦数据库处理的慢一些，连接数就会暴涨。</p><p>max_connections参数，用来控制一个MySQL实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。对于被拒绝连接的请求来说，从业务交付看就是数据库不可用。</p><p>在机器负载比较高的时候，处理现有请求的时间变长，每个连接保持的时间也更长。这时，再有新建连接的话，就可能会超过max_connections的限制。</p><p>碰到这种情况时，一个比较自然的想法，就是调高max_connections的值。但这样做是有风险的。因为设计max_connections这个参数的目的是想保护MySQL，如果我们把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源消耗在权限验证等逻辑上，如果可能是适得其反，已经连接的线程拿不到CPU资源去执行业务的SQL的请求。</p><h3 id="第一种方法：先处理掉哪些站着连接但是不工作的线程。"><a href="#第一种方法：先处理掉哪些站着连接但是不工作的线程。" class="headerlink" title="第一种方法：先处理掉哪些站着连接但是不工作的线程。"></a>第一种方法：先处理掉哪些站着连接但是不工作的线程。</h3><p>max_connections的计算，不是看谁在running，是只要连着就占用一个计数位置。对于哪些不需要保持的连接，我们可以通过kill connection 主动踢掉。这个行为跟事先设置wait_timeout的效果是一样的。设置wait_timeout参数表示的是，一个线程空闲wait_timeout这么多秒之后，就会被MySQL直接断开连接。</p><p>但是需要注意，在show processlist的结果里，踢掉显示为sleep的线程，可能是有损的。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200225120749.png"></p><p>上面这个例子里，如果断开sessionA的连接，因为这个时候sessionA还没有提交，所以MySQL只能按照回滚事务来处理；而断开sessionB的连接，就没什么大影响。所以，如果按照优先级来说，你应该优先断开像sessionB这样的<strong>事务外空闲的连接</strong></p><p>但是，怎么判断哪些是事务外的空闲呢？sessionC在T时刻之后的30秒执行show processlist，看到的结果是这样的。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200225121422.png"></p><p>图中id=4 和id=5的两回话都是Sleep状态。而要看事务具体状态的话，你可以查information_schema库innodb_trx表。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200225121639.png"></p><p>这个结果里，trx_mysql_thread_id=4,表示id=4的线程还处在事务中。</p><p>因此，如果是连接数过多，可以优先判断事务外空闲太久的连接；如果这样还不够，在考虑断开事务内空闲太久的连接。</p><p>从服务端断开连接使用的是kill connection + id 的命令，一个客户端处于sleep状态时，它的连接被服务端主动断开后，这个库护短并不会马上知道。知道客户端子啊发起下一个请求的时候，才会收到这样的报错”ERROR 2013 (HY000):Lost connection to MySQL server during query”。</p><p>从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端开上去，“MySQL一直没恢复”。</p><h3 id="第二种方法：减少连接过程的消耗。"><a href="#第二种方法：减少连接过程的消耗。" class="headerlink" title="第二种方法：减少连接过程的消耗。"></a>第二种方法：减少连接过程的消耗。</h3><p>有的业务代码会在短时间内先大量申请数据库连接备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。</p><p>跳过权限验证的方法是：重启数据库，并使用-skip-grant-tables参数启动。这样，整个MySQL会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。</p><p>但是这种方法特别符合标题说的“饮鸩止渴”，风险极高，是特别不建议使用的方案。尤其你的库外网可以访问的话，就更不能这么做了。</p><p>在MySQL 8.0版本里，如果你启动-skip-grant-tables参数，MySQL还会默认把–skip-networking参数打开，表示这时候数据库只能被本地的客户端连接。</p><p>除了短连接数暴增可能会带来性能问题外，实际上，我们线上碰到更多的是查询或者更新语句导致的性能问题。其中，查询问题比较典型的有两类，一类是由新出现的慢查询导致的，一类是由QPS突增导致的。而关于更新语句导致的性能问题，后面会介绍。</p><h2 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h2><p>在MySQL中，会引发性能问题的慢查询，大体有以下三种可能：</p><ol><li>索引没有设计好；</li><li>SQL语句没写好；</li><li>MySQL选错了索引；</li></ol><p>接下来，具体分析一下这三种可能,以及应对的解决方案。</p><p>导致慢查询的第一种可能是，索引没有设计好。</p><h3 id="导致慢查询的第一种可能是，索引没有设计好"><a href="#导致慢查询的第一种可能是，索引没有设计好" class="headerlink" title="导致慢查询的第一种可能是，索引没有设计好"></a>导致慢查询的第一种可能是，索引没有设计好</h3><p>这种场景一般就是通过紧急创建索引解决。MySQL5.6版本以后，创建索引都支持Online DDL了，对于这种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行alter table语句。</p><p>比较理想的是能在备库执行。假设你现在的服务是一主一备，主库A、备库B，这个方案的大致流程是这样：</p><ol><li>在备库B执行set sql_log_bin = off,也就是不写binlog，然后执行alter table 语句加上索引；</li><li>执行猪备切换；</li><li>这时候主库是B，备库是A。在A上执行set sql_log_bin = off，然后执行alter table 语句加上索引。</li></ol><p>这个一个“古老”的DDL方案。平时的做变更的时候，你应该考虑类似gh-ost这样的方案，更加稳妥。但是在需要紧急处理时，上面这个方案的效率更高。</p><h3 id="导致慢查询的第二种可能是，语句没写好。"><a href="#导致慢查询的第二种可能是，语句没写好。" class="headerlink" title="导致慢查询的第二种可能是，语句没写好。"></a>导致慢查询的第二种可能是，语句没写好。</h3><p>这时，我们可以通过改写SQL语句处理。MySQL5.7提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。</p><p>比如，语句备错误的写成了select * from t where id+1 = 10000，你可以通过下面的方式，增加以恶搞语句改写规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> query_rewrite.rewrite_rules(<span class="keyword">pattern</span>, replacement, pattern_database) <span class="keyword">values</span> (&quot;select * from t where id + 1 = ?&quot;, &quot;select * from t where id = ? - 1&quot;, &quot;db1&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></table></figure><p>这里，call query_rewrite.flush_rewrite_rules()这个存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200312223516.png"></p><h3 id="导致慢查询的第三种可能，就是碰上了我们在MySQL为什么会选错索引-中提到的情况，"><a href="#导致慢查询的第三种可能，就是碰上了我们在MySQL为什么会选错索引-中提到的情况，" class="headerlink" title="导致慢查询的第三种可能，就是碰上了我们在MySQL为什么会选错索引 中提到的情况，"></a>导致慢查询的第三种可能，就是碰上了我们在MySQL为什么会选错索引 中提到的情况，</h3><p>这个时候，应急方案就是给这个语句加上force index。<br>同样的，使用查询重写功能，给原来的语句加上force index，也可以解决这个问题。</p><p>上面讨论的由慢查询导致性能问题的三种情况，实际上出现做多的是前两种，即：索引没设计好和语句没写好。而这两种情况，恰恰是完全可以避免的。</p><ol><li>上线前，在测试环境，把慢查询日志(slow log)打开，并且把long_query_time设置成0，确保每个语句都会被记录入慢查询日志；</li><li>在测试表里插入模拟线上的数据，做一遍回归测试；</li><li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致。</li></ol><p>不要吝啬这段花在上线前的“额外”时间，因为这会帮你省下很多故障复盘的时间。</p><p>如果新增的SQL语句不多，手动跑一下就可以。而如果是新项目的话，或者是修改了原有项目的表结构设计，全量回归测试都是必要的。这时候，你需要工具帮你检查所有的sql语句的返回结果。可以使用开源工具pt-query-digest <a href="https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html">https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html</a></p><h2 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h2><p>有时候由于业务突然出现高峰，或者应用程序bug，导致某个语句的QPS突然暴涨，也可能导致MySQL压力过大，影响服务。</p><p>一类情况是，由一个新功能的bug导致的，当然，最理想的情况是让业务把这个功能下掉，服务自然就会恢复。</p><ol><li><p>一种是由全新的业务的bug导致的。假设你的DB运维是比较规范的，也就是生活很好白名单是一个一个加的。这个种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没有那么快，那么就可以从数据库端直接把白名单去掉。</p></li><li><p>如果这个新功能使用的单独的数据库用户，那么管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</p></li><li><p>如果这个新增的功能跟主体功能都是部署在一起的，那么只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成“select 1” 返回。</p></li></ol><p>当然，这个操作的风险很高，需要特别细致。他可能存在两个副作用：</p><ol><li>如果别的功能里面也用到这个SQL语句模版，会误伤；</li><li>很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这个语句以select1 的结果返回的话，可能会导致后面的业务逻辑一起失败。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL实践篇-MySQL有哪些“饮鸩止渴”提高性能的方法？&quot;&gt;&lt;a href=&quot;#MySQL实践篇-MySQL有哪些“饮鸩止渴”提高性能的方法？&quot; class=&quot;headerlink&quot; title=&quot;MySQL实践篇-MySQL有哪些“饮鸩止渴”提高性能的方法</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://vincentxin-scott.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实践篇-为什么只改一行语句，锁那么多？</title>
    <link href="https://vincentxin-scott.github.io/2020/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C17%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%B9%E4%B8%80%E8%A1%8C%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%94%81%E9%82%A3%E4%B9%88%E5%A4%9A/"/>
    <id>https://vincentxin-scott.github.io/2020/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C17%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%B9%E4%B8%80%E8%A1%8C%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%94%81%E9%82%A3%E4%B9%88%E5%A4%9A/</id>
    <published>2020-02-16T12:44:22.432Z</published>
    <updated>2020-04-23T01:23:36.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么只改一行语句，锁那么多？"><a href="#为什么只改一行语句，锁那么多？" class="headerlink" title="为什么只改一行语句，锁那么多？"></a>为什么只改一行语句，锁那么多？</h1><p>主要说明 语句的加锁规则。</p><p>MySQL后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即5.X系列&lt;=5.7.24，8.0系列&lt;=8.0.13。</p><p>因为间隙锁在可重复读隔离级别下才有效，所以以下的描述中，除了特别说明，默认是可重复读隔离级别。</p><p><strong>加锁规则里面，包含了两个“原则”、“两个优化”和一个“bug”</strong></p><ol><li>原则1:加锁的基本单位是next-key lock。next-key lock是前开后闭区间。</li><li>原则2:查找过程中访问到的对象才会加锁。</li><li>优化1:索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li><li>优化2:索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li><li>一个bug:唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><h2 id="案例一-等值查询间隙锁"><a href="#案例一-等值查询间隙锁" class="headerlink" title="案例一:等值查询间隙锁"></a>案例一:等值查询间隙锁</h2><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200219105814.png"></p><p>由于表t中没有id=7的记录，所以用上面提到的加锁规则判断一下的话:</p><ol><li>根据原则1，加锁的单位是next-key lock，sessionA加锁的范围是（5，10];</li><li>同时根据优化2，这是一个等值查询(id=7)，而id=10不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是(5,10)</li></ol><p>所以，sessionB要往这个间隙里面插入id=8的记录会被锁住，但是sessionC修改的id=10这行是可以的。</p><h2 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h2><p>关于覆盖索引上的锁：<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200219110324.png"></p><p>看到这个例子，有一种“该锁的不锁，不该锁的乱锁”的感觉？</p><p>这里sessionA给索引c上的c=5的这行加上读锁。</p><ol><li>根据原则1，加锁的单位是next-key lock，因此会给(0,5]加上next-key lock。</li><li>要注意c是普通索引，因此仅访问c=5这条记录是不能马上停下来的，需要向右遍历，查到c=10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加上next-key lock。</li><li>但是同时这个符合优化2:等值判断，向右遍历，最后一个值不满足c=5这个等值条件，因此退化成间隙锁(5,10).</li><li>根据原则2，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么sessionB的update语句可以执行完成。</li></ol><p>但sessionC要插入一个(7,7,7)的记录，就会被sessionA的间隙锁(5,10)锁住。</p><p>需要注意，这个例子中，lock in share mode只锁覆盖索引，但是如果是for update就不一样了。执行for update时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p><p>这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。</p><h2 id="案例三-主键索引范围锁"><a href="#案例三-主键索引范围锁" class="headerlink" title="案例三:主键索引范围锁"></a>案例三:主键索引范围锁</h2><p>关于范围查询</p><p>思考：下面两条查询语句，加锁范围相同吗？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>逻辑上，这两条查询语句肯定是等价的，但是它们的加锁规则不太一样。<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200219111816.png"></p><ol><li>开始执行的时候，要找到第一个id=10的行，因此本该是next-key lock(5,10]。根据优化1，主键id上的等值条件，退化成行锁，只加了id=10这一行的行锁。</li><li>范围查找就往后继续找，找到id=15这行停下来，因此需要加next-key lock(10,15]。</li></ol><p>所以sessionA这时候加锁的范围就是主键索引上，行锁id=10和next-key lock(10,15]。这样，sessionB和sessionC的结果就容易理解了。</p><p>这里需要注意，首次sessionA定位查找id=10的行的时候，是当作等值查询来判断的，而向右扫描到id=15的时候，用的是范围查询判断。</p><h2 id="案例四-非唯一索引范围锁"><a href="#案例四-非唯一索引范围锁" class="headerlink" title="案例四:非唯一索引范围锁"></a>案例四:非唯一索引范围锁</h2><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200219112440.png"></p><p>这次sessionA用字段c来判断。加锁规则跟案例三唯一的不同是:在第一次用c=10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终sessionA加的锁是，索引c的(5,10]和(10,15]这两个next-key lock。</p><p>这里扫描到c=15才能停止扫描，是合理的，因为InnoDB要扫到c=15，才知道不需要就绪往后找了。</p><h2 id="案例五-唯一索引范围锁bug"><a href="#案例五-唯一索引范围锁bug" class="headerlink" title="案例五:唯一索引范围锁bug"></a>案例五:唯一索引范围锁bug</h2><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200219143249.png"></p><p>sessionA是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id15这一行就应该停止。</p><p>但是现实上，InnoDB会往前扫到第一个不满足条件为止，也就是id=20.而且由于这是范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。</p><p>所以看到了，sessionB要更新id=20这一行，是会被锁住的。同样的，sessionC要插入id=16的行，也会被锁住的。</p><p>照理说，这里锁住id=20这行的行为，其实是没有必要的。因为扫描到id=15，就可以确定不用再往后找了。但实现上还是这么做了，因此认为这是个bug。</p><h2 id="案例六-非唯一索引上存在“等值”的例子"><a href="#案例六-非唯一索引上存在“等值”的例子" class="headerlink" title="案例六:非唯一索引上存在“等值”的例子"></a>案例六:非唯一索引上存在“等值”的例子</h2><p>为了更好地说明“间隙”这个概念。这里，我给表插入一条新记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">30</span>,<span class="number">10</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>新插入的这一行c=10，也就是说现在表里有两个c=10的行。那么，这时候索引c上的间隙时候什么状态呢？由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200224134324.png"></p><p>可以看到，虽然有两个c=10，但是它们的主键值id是不同的(分别是10和30)，因此这两个c=10的记录之间，也是有间隙的。</p><p>用delete语句来验证。注意：delete语句加锁的逻辑，其实跟select…for update是类似的，也就是在文章开头总结的两个原则两个优化和一个bug。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200224134723.png"></p><p>这是sessionA在遍历的时候，先访问第一个c=10的记录，根据规则1，这里加的是(c=5,id=5)到(c=10，id=10)这个next-key lock。</p><p>然后，sessionA向右查找，直到碰到(c=15,id=15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c=10,id=10)到(c=15，id=15)的间隙锁。</p><p>也就说这个delete语句在索引c上的加锁范围，就是下面蓝色的区域。<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200224135359.png"></p><p>这个蓝色区域左右两边都是虚线，表示开区间。</p><h2 id="案例七：limit语句加锁"><a href="#案例七：limit语句加锁" class="headerlink" title="案例七：limit语句加锁"></a>案例七：limit语句加锁</h2><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200224135704.png"><br>这个例子里，sessionA的delete语句加了limit2。你知道表t里c=10的记录其实i之i有两条，因此加不加limit2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，sessionB的insert语句执行通过了，跟案例六的结果不同。</p><p>这是因为，案例七的delete语句明确加了limit2的限制，因此在遍历到(c=10,id=30)这一行之后，满足条件的语句已经有两条，循环就结束了。</p><p>因此，索引c上的加锁范围就变成了从(c=5,id=5)到(c=10,id=30)这个前开后闭区间。<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200224154400.png"></p><p>可以看到，(c=10,id=30)之后的这个间隙并没有在加锁范围里，因此insert语句插入c=12是可以执行成功的。</p><p>这个例子对我们的指导意义：在删除数据的时候尽量加limit。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加搜的范围。</p><h2 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h2><p>说明：next-key lock 实际上是间隙锁和行锁加起来的结果</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200224205825.png"></p><ol><li>sessionA启动事务后执行查询语句加lock in share mode，在索引c上加next-key lock(5,10]和(10,15)间隙锁；</li><li>sessionB的update语句也要在索引c上加next-key lock (5,10],进入锁等待；</li><li>然后sessionA要插入一行(8,8,8)这一行，被sessionB的间隙锁锁住。由于出现了死锁，InnoDB 让sessionB回滚。</li></ol><p>sessionB的next-key lock 不是没有申请成功吗？</p><p>其实，sessionB的“加 next-key lock(5,10]”操作，实际上分成了两步，先是加(5,10)的间隙锁，加锁成功；然后加c=10的行锁，这时候才被锁住的。</p><p>也就说，我们在分析加锁规则的时候可以用next-key lock 来分析。但是要知道，具体执行的时候是要分成间隙锁和行锁两段来执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么只改一行语句，锁那么多？&quot;&gt;&lt;a href=&quot;#为什么只改一行语句，锁那么多？&quot; class=&quot;headerlink&quot; title=&quot;为什么只改一行语句，锁那么多？&quot;&gt;&lt;/a&gt;为什么只改一行语句，锁那么多？&lt;/h1&gt;&lt;p&gt;主要说明 语句的加锁规则。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://vincentxin-scott.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实践篇-幻读是什么，幻读有什么问题</title>
    <link href="https://vincentxin-scott.github.io/2020/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C16%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
    <id>https://vincentxin-scott.github.io/2020/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C16%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-12T15:00:59.409Z</published>
    <updated>2020-04-23T01:23:36.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="幻读是什么，幻读有什么问题？"><a href="#幻读是什么，幻读有什么问题？" class="headerlink" title="幻读是什么，幻读有什么问题？"></a>幻读是什么，幻读有什么问题？</h1><p>🌰：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这个表除了主键id外，还有一个索引c，初始化语句在表中插入了6行数据。</p><p>问题：下列语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>这个语句会命中d=5的这一行，对应的主键id=5，因此在select语句执行完成后，id=5这一行会加一个写锁，而且由于两阶段锁协议，这个写锁会执行commit语句的时候释放。</p><p>由于字段d上没有索引，因此这条查询语句会做全表扫描，那么，其他被扫描到的，但是不满足条的5行记录上，会不会被加锁呢？</p><p>InnoDB的默认事务隔离级别是可重复读，所以我们都是在可重读读隔离级别下讨论问题。</p><h2 id="幻读是什么？"><a href="#幻读是什么？" class="headerlink" title="幻读是什么？"></a>幻读是什么？</h2><p>如果只在id=5这一行加锁，而其他行不加锁的话；</p><p>假设是以下场景：</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200214113105.png"></p><p>可以看到sessionA里执行了三次查询，分别是Q1、Q2和Q3。它们的SQL语句相同，都是select * from t where d=5 for update。这个语句的意思就是，查所有d=5的行，而且使用的是当前读，并且加上了写锁。</p><ol><li>Q1只返回id=5这一行；</li><li>在T2时刻，sessionB 把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这两行。</li><li>在T4时刻，sessionC又插入一行(1,1,5)，因此T5时刻Q3查出来的是id=0、id=1和id=5这两行。</li></ol><p>其中Q3读到id=1这一行的现象，被称为幻读。也就是说，幻读值的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p><p><strong>对“幻读”做一个说明：</strong></p><ol><li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的，因此，幻读在“当前读“才会出现。</li><li>上面sessionB的修改结果，被sessionA之后的select语句当作”当前读“看到，不能称为幻读。<strong>幻读仅专指”新插入的行“</strong></li></ol><p>因为这个三个查询都是加入了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。并且 sessionB和sessionC的两条语句，执行后就会提交，所以Q2和Q3就是应该看到和这个两个事务的操作效果，而且也看到了，这个跟事务的可见性规则并不矛盾。</p><h2 id="幻读有什么问题？"><a href="#幻读有什么问题？" class="headerlink" title="幻读有什么问题？"></a>幻读有什么问题？</h2><p><strong>首先语义上</strong>：sessionA在T1时刻就声明了，“我要把所有d=5的行锁住,不准别的事务进行读写操作”。而实际上，这个语义被破坏了。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200214213406.png"></p><p>sessionB的第二条语句update t set c=5 where id=0，语义是“我把id=0、d=5这一行的c值，改成5”。</p><p>由于在T1时刻，sessionA还只是给id=5这一行加了行锁，并没有给id=0这行加上锁。因此，sessionB在T2时刻，是可以执行这两条update语句的。这样，就破坏了sessionA里Q1语句要锁住所有d=5的行的加锁声明。</p><p>sessionC也是一样的道理，对id=1这行的修改，也是破坏了Q1的加锁声明。</p><p><strong>数据一致性问题</strong>。我们知道，锁的设计是为了保证数据的一致性。而这个一致性，不只是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p><p>为了说明这个问题，我给session A在T1时刻再加上一个更新语句，即：update t set d=100 where d=5。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200214214828.png"></p><p>update的加锁语义和select…for update是一致的，所以这个时候加上这条update语句也很合理。sessionA声明说“要给d=5的语句加上锁”，就是为了要更新数据，新加的这条update语句就是把它认为加上了锁的这行的d值修改成了100。</p><ol><li>经过T1时刻，id=5这一行变成(5,5,100)，当然这个结果最终是在T6时刻正式提交的；</li><li>经过T2时刻，id=0这一行变成(0,5,5);</li><li>经过T4时刻，表里面多了一行(1,5,5);</li><li>其他行跟这个执行序列无关，保持不变。</li></ol><p>这样看，这些数据也没啥问题，但是我们再来看看这个时候binlog里面的内容。</p><ol><li>T2时刻，sessionB事务提交，写入两条语句；</li><li>T4时刻，sessionC事务提交，写入两条语句；</li><li>T6时刻，sessionA事务提交，写入了update t set d=100 where d=5这条语句。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/*所有d=5的行，d改成100*/</span></span><br></pre></td></tr></table></figure><p>这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个库，这三行的结果，都变成了(0,5,100)、(1,5,100)和(5,5,100)。</p><p>也就是说，id=0和id=1这两行，发生了数据不一致。</p><p>我们来分析一下，数据不一致到底是怎么引入的，假设“select * from where d=5 for update 这条语句只给d=5这一行，也就是id=5这一行加锁”导致的。</p><p>所以上面的假设都不合理，改成扫描过程中碰到的行，也都加上写锁。再看看执行效果。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200214223600.png"></p><p>由于sessionA把所有的行都加了写锁，所以sessionB在执行一个update语句的时候就被锁住了。需要等到T6时刻sessionA提交以后，sessionB才能继续执行。</p><p>这样对于id=0这一行，在数据库里的最终结果还是(0,0,5)。在binlog里面，执行序列是这样的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/*所有d=5的行，d改成100*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br></pre></td></tr></table></figure><p>可以看到，按照日志的顺序执行行，id=0这一行的最终结果也是(0,0,5)所以，id=0这一行的问题解决了。</p><p>但同时，id=1这一行，在数据库里面的结果是(1,5,5),而根据binlog的执行结果是(1,5,100),也就是说幻读的问题还是没有解决。</p><p>也就说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，这也是为什么“幻读”会被单独拿出来解决的原因。</p><h2 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h2><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。</p><p>顾名思义，间隙锁，锁的就两个值之间的空隙。比如文章开头的表t，初始化插入6个记录，这就产生了7个间隙。<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200214225407.png"></p><p>这样当你select * from t where d=5 for update的时候，就不止是给数据库中已有的6个记录加上行锁。还同时加了7个间隙锁。这样就确保无法再插入新的记录。</p><p>也就说这时候，在一行行扫描的过程中，不仅仅将给行上加了行锁，还给行两边的空隙，也加上了间隙锁。</p><p>数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之间碰到过的锁都不太一样。</p><p>比如行锁，分成读锁和写锁。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200214225800.png"></p><p>也就说，跟行锁冲突关系的是“另外一个行锁”</p><p>但是间隙锁不一样，<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong>间隙锁之间不存在冲突关系。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200214225952.png"><br>这里sessionB并不会被堵住。因为表t里并没有c=7这个记录，因此sessionA加的是间隙锁(5,10)。而sessionB也是在这个间隙加的间隙锁。它们有共同的目标，即：保护和这个间隙，不允许插入值。但是它们之间不冲突。</p><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就说，我们表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是(-∞，0]、(0，5]、(5，10]、(10，15]、(15，20]、(20，25]、(25，supremum]。</p><p>间隙锁和next-key lock的引入，帮助我们解决了幻读的问题，但同时也带来了一些“困扰”。</p><p>业务逻辑：任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span>N <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果行不存在*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(N,N,N);</span><br><span class="line"><span class="comment">/*如果行存在*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span>N <span class="keyword">set</span> id<span class="operator">=</span>N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>可能你会说，这个不是insert…on duplicate key update就能解决吗？但其实在有多个唯一键的时候，这个方法是不能满足这个需求的。</p><p>这个逻辑一旦有并发，就会碰到死锁。这个逻辑每次操作前用for update锁起来，已经是最严格的模式了，怎么会有死锁呢？</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200214231205.png"></p><p>其实都不需要用到的update语句，就已经形成死锁了。我们按照语句执行顺序来分析一下：</p><ol><li>sessionA执行select…for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10)</li><li>sessionB执行select…for update语句，同样会加上间隙锁(5,10),间隙锁之间不会冲突，因此这个语句可以执行成功；</li><li>sessionB试图插入一行(9,9,9),被sessionA的间隙锁挡住了，只好进入等待；</li><li>sessionA试图插入一行(9,9,9),被sessionB的间隙锁挡住了。</li></ol><p>至此，两个sessiion进入相互等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让sessionA的insert报错返回了。</p><p><strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</strong></p><p>间隙锁是在可重读隔离级别下才会生效的。所以，如果把隔离级别设置成读提交的话，就没有间隙锁了，但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;幻读是什么，幻读有什么问题？&quot;&gt;&lt;a href=&quot;#幻读是什么，幻读有什么问题？&quot; class=&quot;headerlink&quot; title=&quot;幻读是什么，幻读有什么问题？&quot;&gt;&lt;/a&gt;幻读是什么，幻读有什么问题？&lt;/h1&gt;&lt;p&gt;🌰：&lt;/p&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://vincentxin-scott.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实践篇-慢查询</title>
    <link href="https://vincentxin-scott.github.io/2020/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C15%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9F%A5%E8%AF%A2%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B9%9F%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2/"/>
    <id>https://vincentxin-scott.github.io/2020/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C15%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9F%A5%E8%AF%A2%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B9%9F%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2/</id>
    <published>2020-02-11T13:04:48.078Z</published>
    <updated>2020-04-23T01:23:36.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么只查一行的语句，也执行这么慢？"><a href="#为什么只查一行的语句，也执行这么慢？" class="headerlink" title="为什么只查一行的语句，也执行这么慢？"></a>为什么只查一行的语句，也执行这么慢？</h1><p>如果是MySQL数据库本身就有很大的压力，导致数据库服务器CPU占用绿很高或ioutil(IO利用率)很高，这种情况下所有的语句的执行都有可能很慢，这里不讨论。</p><p>为了便于描述，我还是构造一个表，基于这个表来说明问题。这个表有两个字段id和c，并且我在里面插入了10万行记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>) do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><h2 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h2><p>执行sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询结果上时间不返回。</p><p>一般碰到这种情况的话，大概率是表t被锁住了。一般都是首先执行一下show processlist命令，看看当前语句处于什么状态。</p><p>然后针对每种状态，分析产生的原因，如何复现，以及如何处理。</p><h3 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h3><p>使用show processlist命令查看Waiting for table metadata lock的示意图。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211211622.png"></p><p>出现这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。</p><p>这类问题的处理方式，就是找到谁持有MDL写锁，然后把它kill掉。</p><p>但是，由于在show processlist的结果里面，sessionA的Command列是“Sleep”，导致查找起来不方便。不过有了performance_schema和sys系统库以后，就方便多了。(MySQL启动时需要设置performance_schema=on,相比于设置为off会有10%左右的性能损失)</p><p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill命令断开即可。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211212319.png"></p><h3 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h3><p>在表t上，执行下面的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.processlist <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211212440.png"></p><p>这个状态表示的是，现在有一个线程正要对表t做flush操作。MySQL里面对表做flush操作的用法，一般有一下两个：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">flush tables t <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure><p>这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关闭MySQL里所有打开的表。</p><p>但是正常这个两个语句执行起来都很快，除非他们呢被别的线程堵住了。</p><p>所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住了，然后它又堵住了我们的select 语句。</p><p>复现步骤：<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211213038.png"></p><p>在sessionA中，故意没行都调用一次sleep(1),这样这个语句默认要执行10万秒，在这期间表t一直被sessionA”打开”着。然后，sessionB的flush tables t命令再要去关闭表t，就需要等sessionA的查询结果，这样session C要再次查询的话，就会被flush命令堵住了。</p><p>通过show processlist命令查看的结果：<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211213330.png"></p><h3 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode; </span><br></pre></td></tr></table></figure><p>由于访问id=1这个记录时要加读锁，如果这个时候已经有事务在这行记录上持有一个写锁，select会被堵住。</p><p>复现步骤如下：</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211213706.png"></p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211213723.png"></p><p>session A启动了事务，占有写锁，还提交，是导致sessionB被堵住的原因。</p><p>如果是MySQL5.7版本，可以通过sys.innodb_lock_waits表查到。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t sys.innodb_lock_waits <span class="keyword">where</span> locked_table<span class="operator">=</span><span class="string">&#x27;`test`.`t`&#x27;</span>\G</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211214015.png"></p><p>可以看到，4号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是KILL QUERY 4或KILL 4。</p><p>实际上，KILL 4 才有效，也就说直接断开这个连接。这里隐含的一个逻辑就是，连接断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了id=1上的行锁。</p><h2 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span><span class="number">50000</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。</p><p>注意：为了把所有语句记录到show log里，我在连接后先执行了set long_query_time=0,将慢查询日志的时间阀值设置为0。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211215109.png"></p><p>Rows_examined显示扫描了50000行。<strong>坏查询不一定是慢查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>虽然扫描行数是1，但执行时间却长达800毫秒。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211220125.png"></p><p>如果执行语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><p>执行扫描行数也是1行，执行时间是0.2毫秒。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211220332.png"></p><p>按理说 lock in share mode还要加锁，时间应该更长才对。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211220452.png"></p><p>第一个语句的查询结果里c=1,带lock in share mode的语句返回的是c=1000001。</p><p>复现步骤：<br><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211220559.png"></p><p>sessionA先用start transaction with consistent snapshot 命令启动了一个事务，之后session B才开始执行update语句。</p><p>sessionB执行完100万次update语句后 ID=1这行什么状态？</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200211220751.png"></p><p>sessionB更新完100万次，生成了100万个回滚日志(undo log)。</p><p>带lock in share mode 的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id =1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次后，才将1这个结果返回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么只查一行的语句，也执行这么慢？&quot;&gt;&lt;a href=&quot;#为什么只查一行的语句，也执行这么慢？&quot; class=&quot;headerlink&quot; title=&quot;为什么只查一行的语句，也执行这么慢？&quot;&gt;&lt;/a&gt;为什么只查一行的语句，也执行这么慢？&lt;/h1&gt;&lt;p&gt;如果是MyS</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://vincentxin-scott.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实践篇-SQL逻辑相同，性能却差异巨大</title>
    <link href="https://vincentxin-scott.github.io/2020/02/09/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C14SQL%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C,%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/"/>
    <id>https://vincentxin-scott.github.io/2020/02/09/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%EF%BD%9C14SQL%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C,%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/</id>
    <published>2020-02-09T07:14:50.933Z</published>
    <updated>2020-04-23T01:23:36.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么这些SQL语句逻辑相同，性能却差异巨大？"><a href="#为什么这些SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="为什么这些SQL语句逻辑相同，性能却差异巨大？"></a>为什么这些SQL语句逻辑相同，性能却差异巨大？</h1><h2 id="案例一：条件字段函数操作"><a href="#案例一：条件字段函数操作" class="headerlink" title="案例一：条件字段函数操作"></a>案例一：条件字段函数操作</h2><p>假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号(tradeid)、交易员id(operator)、交易时间(t_modified)等字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tradelog` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `operator` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>现在已经记录了从2016年初到2018年底的所有数据，运营部门有一个需求，要统计发生在所有年份中7月份的交易记录总数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)<span class="operator">=</span><span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>由于t_modified字段上有索引，直接执行SQL，却发现执行很久，才能返回结果。</p><p><strong>如果你对字段做了函数计算，就用不上索引了，这是MySQL的规定</strong></p><p>下面是这个t_modified索引的示意图，方框上面的数字是month()函数对应的值。</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200209152245.png"></p><p>如果计算mouth()函数的话，传入7的时候，第一层就不知道该接下来如何处理了。</p><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能</strong></p><p>优化器不是要放弃使用这个索引，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引t_modified,优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比遍历主键索引来的更快。最终还是会选择索引t_modified.</p><p>使用explain命令</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200209173659.png"></p><p>key=‘t_modified’表示的是，使用了t_modified这个索引；在测试表数据中插入10万行数据，rows=100335，说明这条扫描了整个索引的所有值；Extra字段的Using index，表示的是使用了覆盖索引。</p><p>也就是说，由于在t_modified字段加了month()函数操作，导致了全索引扫描。为了能够用上索引的快速定位能力，我们把SQL语句改成基于字段本身的范围查询。按照下面这个写法，优化器就能按照我们预期的，用户是那个t_modified索引的快速定位能力了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2016-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2016-8-1&#x27;</span>) <span class="keyword">or</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2017-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2017-8-1&#x27;</span>) <span class="keyword">or</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2018-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2018-8-1&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="案例二：隐式类型转换"><a href="#案例二：隐式类型转换" class="headerlink" title="案例二：隐式类型转换"></a>案例二：隐式类型转换</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid<span class="operator">=</span><span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>交易编号tradeid这个字段上，本来就有索引，但是explain的结果却显示，这条语句需要走全表扫描。你可能发现了，tradeid的字段类型是varchar(32),<strong>而输入的参数却是整型，所以需要做类型转换。</strong></p><p>现在这里有两个问题：</p><ol><li>数据类型转换的规则是什么？</li><li>为什么有数据类型转换，就需要走全索引扫描?</li></ol><p>这里有一个简单的方法，看select “10”&gt;9的结果：</p><ol><li>如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是1；</li><li>如果规则是“将数字转成字符串”，那么就做字符串比较，结果应该是0;</li></ol><p>在MySQL中，字符串和数字做比较的话，是将字符串转成数字。</p><p>这时全表扫描的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid<span class="operator">=</span><span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>对于优化器来说，相当于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span>  <span class="built_in">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>也就说，这条语句出发上面提到的规则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><h2 id="案例三：隐式字符编码转换"><a href="#案例三：隐式字符编码转换" class="headerlink" title="案例三：隐式字符编码转换"></a>案例三：隐式字符编码转换</h2><p>假设系统还有另外一个表，trade_detail，用于记录交易的操作细节。为了便于量化分析和复现，交易日志表tradelog和交易详情表trade_detail这两个表插入一些数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `trade_detail` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `trade_step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*操作步骤*/</span></span><br><span class="line">  `step_info` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*步骤信息*/</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这时候，如果要查询id=2的交易的所有操作步骤信息，SQL语句可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>; <span class="comment">/*语句Q1*/</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200209180003.png"></p><p>我们一起来看一下这个结果：</p><ol><li>第一行显示优化器会先在交易记录表tradelog上查到id=2的行，这个步骤用上了主键索引，rows=1表示扫描一行；</li><li>第二行key=NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。</li></ol><p>在这个执行计划里，是从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因此，我们把tradelog称为驱动表，把trade_detail称为被驱动表，把tradeid称为关联字段。</p><p>我们看一下这个explain结果的执行流程：</p><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200209180454.png"></p><p>图中：</p><ul><li>第一步，是根据id在tradelog表里找到L2这行；</li><li>第二步，是从L2中取出tradeid字段的值；</li><li>第三步，是根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的key=NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是否匹配。</li></ul><p>进行到这里，你会发现第3步不符合我们的预期，因为表trade_detail里tradeid字段上是有索引的，我们本来是希望通过使用tradeid索引能够快速定位到等值的行。</p><p>这个两个表的字符集不同，一个是utf8，一个是utf8mb4,所以做表连接查询的时候用不上关联字段的索引。</p><p>我们说问题是出在执行步骤的第3步，如果单独把这个步骤改成SQL语句的话，那就是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail <span class="keyword">where</span> tradeid<span class="operator">=</span>$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p>其中，$L2.tradeid.value的字符集是utf8mb4。</p><p>字符集utf8mb4是utf8的超集，当这两个类型的字符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。</p><blockquote><p>这个设定很好理解，utf8mb4是utf8的超集。类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方向”进行转换的。</p></blockquote><p>也就是说，实际上这个语句等同于下面这个写法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail  <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)<span class="operator">=</span>$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。</p><p>这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><p>连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</p><p>作为对比验证，“查找trade_detail表里id=4的操作，对应的操作者是谁”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">select</span> l.operator <span class="keyword">from</span> tradelog l , trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> d.id<span class="operator">=</span><span class="number">4</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200210121226.png"></p><p>这个语句里trade_detail表变成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了被驱动表tradelog里的索引(tradeid),扫描行数是1。</p><p>这也是两个tradeid字段的join操作，<strong>为什么这次能用上被驱动表的tradeid索引呢？</strong></p><p>假设驱动表trade_detail里id=4的行记为R4，那么在连接的时候，被驱动表tradelog上执行的就是类似这样的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> operator <span class="keyword">from</span> tradelog  <span class="keyword">where</span> traideid <span class="operator">=</span>$R4.tradeid.value; </span><br></pre></td></tr></table></figure><p>这时候$R4.tradeid.value的字符集是utf8，按照字符集转换规则(<strong>因为utf8mb4是utf8的超集，所以要将utf8转成utf8mb4</strong>)，要转成utf8mb4，所以这个过程被改写成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> operator <span class="keyword">from</span> tradelog  <span class="keyword">where</span> traideid <span class="operator">=</span><span class="keyword">CONVERT</span>($R4.tradeid.value <span class="keyword">USING</span> utf8mb4); </span><br></pre></td></tr></table></figure><p>这里的CONVERT函数是加在输入参数上的，这样就可以用上被驱动表tradeid索引。</p><p>理解原理以后，就可以用来指导操作了。如果优化语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>的执行过程，有两种方法：</p><ul><li>比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就没有字符集转换的问题了。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> trade_detail modify tradeid <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">default</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li>如果能够修改字段的字符集的话，是最好不过了，但如果数据量比较大，或者业务上暂时不能做这个DDL的话，那就只能采用修改SQL语句的方法了。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l , trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span><span class="keyword">CONVERT</span>(l.tradeid <span class="keyword">USING</span> utf8) <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>; </span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/vincentxin-scott/img/master/picgo/20200210122510.png"></li></ul><p>这里，主动把l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看到，这次索引走对了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么这些SQL语句逻辑相同，性能却差异巨大？&quot;&gt;&lt;a href=&quot;#为什么这些SQL语句逻辑相同，性能却差异巨大？&quot; class=&quot;headerlink&quot; title=&quot;为什么这些SQL语句逻辑相同，性能却差异巨大？&quot;&gt;&lt;/a&gt;为什么这些SQL语句逻辑相同，性能</summary>
      
    
    
    
    <category term="数据库" scheme="https://vincentxin-scott.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://vincentxin-scott.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
